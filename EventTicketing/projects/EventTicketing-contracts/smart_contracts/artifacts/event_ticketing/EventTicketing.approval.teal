#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8
    bytecblock 0x6173615f6964 0x746f74616c 0x736f6c64 0x6e616d65 0x7072696365
    // smart_contracts/event_ticketing/contract.py:16
    // class EventTicketing(ARC4Contract):
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@8
    pushbytess 0x80b20100 0x653680b8 // method "mint_tickets()uint64", method "buy_ticket(pay)void"
    txna ApplicationArgs 0
    match mint_tickets buy_ticket
    err

main_create_NoOp@8:
    // smart_contracts/event_ticketing/contract.py:16
    // class EventTicketing(ARC4Contract):
    pushbytes 0x0af0d14f // method "create_application(string,uint64,uint64)void"
    txna ApplicationArgs 0
    match create_application
    err


// smart_contracts.event_ticketing.contract.EventTicketing.create_application[routing]() -> void:
create_application:
    // smart_contracts/event_ticketing/contract.py:36-37
    // # --- 1) Create / Init ---
    // @arc4.abimethod(create="require")
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/event_ticketing/contract.py:44
    // self.event_name.value = event_name
    bytec_3 // 0x6e616d65
    uncover 3
    app_global_put
    // smart_contracts/event_ticketing/contract.py:45
    // self.ticket_price.value = ticket_price
    bytec 4 // 0x7072696365
    uncover 2
    app_global_put
    // smart_contracts/event_ticketing/contract.py:46
    // self.total_tickets.value = total_tickets
    bytec_1 // 0x746f74616c
    swap
    app_global_put
    // smart_contracts/event_ticketing/contract.py:47
    // self.tickets_sold.value = UInt64(0)
    bytec_2 // 0x736f6c64
    intc_0 // 0
    app_global_put
    // smart_contracts/event_ticketing/contract.py:48
    // self.ticket_asa_id.value = UInt64(0)
    bytec_0 // 0x6173615f6964
    intc_0 // 0
    app_global_put
    // smart_contracts/event_ticketing/contract.py:36-37
    // # --- 1) Create / Init ---
    // @arc4.abimethod(create="require")
    intc_1 // 1
    return


// smart_contracts.event_ticketing.contract.EventTicketing.mint_tickets[routing]() -> void:
mint_tickets:
    // smart_contracts/event_ticketing/contract.py:53-54
    // # Sadece kurucu
    // assert Txn.sender == Global.creator_address, "Sadece kontrat kurucusu bilet basabilir"
    txn Sender
    global CreatorAddress
    ==
    assert // Sadece kontrat kurucusu bilet basabilir
    // smart_contracts/event_ticketing/contract.py:55-56
    // # Daha önce basılmadı mı?
    // assert self.ticket_asa_id.value == UInt64(0), "Biletler zaten basılmış"
    intc_0 // 0
    bytec_0 // 0x6173615f6964
    app_global_get_ex
    assert // check self.ticket_asa_id exists
    !
    assert // Biletler zaten basılmış
    // smart_contracts/event_ticketing/contract.py:58-68
    // created_asset_id = algopy.itxn.AssetConfig(
    //     asset_name=self.event_name.value,
    //     unit_name="TICKET",
    //     total=self.total_tickets.value,
    //     decimals=0,
    //     default_frozen=False,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    // ).submit().created_asset.id
    itxn_begin
    // smart_contracts/event_ticketing/contract.py:59
    // asset_name=self.event_name.value,
    intc_0 // 0
    bytec_3 // 0x6e616d65
    app_global_get_ex
    assert // check self.event_name exists
    // smart_contracts/event_ticketing/contract.py:61
    // total=self.total_tickets.value,
    intc_0 // 0
    bytec_1 // 0x746f74616c
    app_global_get_ex
    assert // check self.total_tickets exists
    // smart_contracts/event_ticketing/contract.py:64
    // manager=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/event_ticketing/contract.py:65-67
    // reserve=Global.current_application_address,
    // freeze=Global.current_application_address,
    // clawback=Global.current_application_address,
    dupn 3
    itxn_field ConfigAssetClawback
    itxn_field ConfigAssetFreeze
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    // smart_contracts/event_ticketing/contract.py:63
    // default_frozen=False,
    intc_0 // 0
    itxn_field ConfigAssetDefaultFrozen
    // smart_contracts/event_ticketing/contract.py:62
    // decimals=0,
    intc_0 // 0
    itxn_field ConfigAssetDecimals
    itxn_field ConfigAssetTotal
    // smart_contracts/event_ticketing/contract.py:60
    // unit_name="TICKET",
    pushbytes "TICKET"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // smart_contracts/event_ticketing/contract.py:58
    // created_asset_id = algopy.itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/event_ticketing/contract.py:58-68
    // created_asset_id = algopy.itxn.AssetConfig(
    //     asset_name=self.event_name.value,
    //     unit_name="TICKET",
    //     total=self.total_tickets.value,
    //     decimals=0,
    //     default_frozen=False,
    //     manager=Global.current_application_address,
    //     reserve=Global.current_application_address,
    //     freeze=Global.current_application_address,
    //     clawback=Global.current_application_address,
    // ).submit().created_asset.id
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/event_ticketing/contract.py:70
    // self.ticket_asa_id.value = created_asset_id
    bytec_0 // 0x6173615f6964
    dig 1
    app_global_put
    // smart_contracts/event_ticketing/contract.py:50-51
    // # --- 2) Mint tickets (ASA) ---
    // @arc4.abimethod
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.event_ticketing.contract.EventTicketing.buy_ticket[routing]() -> void:
buy_ticket:
    // smart_contracts/event_ticketing/contract.py:73-74
    // # --- 3) Buy ticket (atomic with payment) ---
    // @arc4.abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/event_ticketing/contract.py:76
    // assert self.tickets_sold.value < self.total_tickets.value, "Biletler tükendi"
    intc_0 // 0
    bytec_2 // 0x736f6c64
    app_global_get_ex
    assert // check self.tickets_sold exists
    intc_0 // 0
    bytec_1 // 0x746f74616c
    app_global_get_ex
    assert // check self.total_tickets exists
    dig 1
    >
    assert // Biletler tükendi
    // smart_contracts/event_ticketing/contract.py:77
    // assert self.ticket_asa_id.value != UInt64(0), "Bilet satışı henüz başlamadı"
    intc_0 // 0
    bytec_0 // 0x6173615f6964
    app_global_get_ex
    assert // check self.ticket_asa_id exists
    dup
    assert // Bilet satışı henüz başlamadı
    // smart_contracts/event_ticketing/contract.py:79
    // assert payment.amount == self.ticket_price.value, "Ödeme miktarı bilet fiyatıyla eşleşmiyor"
    dig 2
    gtxns Amount
    intc_0 // 0
    bytec 4 // 0x7072696365
    app_global_get_ex
    assert // check self.ticket_price exists
    ==
    assert // Ödeme miktarı bilet fiyatıyla eşleşmiyor
    // smart_contracts/event_ticketing/contract.py:80
    // assert payment.receiver == Global.current_application_address, "Ödeme bu kontrata yapılmalı"
    uncover 2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Ödeme bu kontrata yapılmalı
    // smart_contracts/event_ticketing/contract.py:82-87
    // # NFT transferi (inner tx)
    // algopy.itxn.AssetTransfer(
    //     xfer_asset=self.ticket_asa_id.value,
    //     asset_receiver=Txn.sender,
    //     asset_amount=1,
    // ).submit()
    itxn_begin
    // smart_contracts/event_ticketing/contract.py:85
    // asset_receiver=Txn.sender,
    txn Sender
    // smart_contracts/event_ticketing/contract.py:86
    // asset_amount=1,
    intc_1 // 1
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/event_ticketing/contract.py:82-83
    // # NFT transferi (inner tx)
    // algopy.itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/event_ticketing/contract.py:82-87
    // # NFT transferi (inner tx)
    // algopy.itxn.AssetTransfer(
    //     xfer_asset=self.ticket_asa_id.value,
    //     asset_receiver=Txn.sender,
    //     asset_amount=1,
    // ).submit()
    itxn_submit
    // smart_contracts/event_ticketing/contract.py:89
    // self.tickets_sold.value = self.tickets_sold.value + UInt64(1)
    intc_1 // 1
    +
    bytec_2 // 0x736f6c64
    swap
    app_global_put
    // smart_contracts/event_ticketing/contract.py:73-74
    // # --- 3) Buy ticket (atomic with payment) ---
    // @arc4.abimethod
    intc_1 // 1
    return
